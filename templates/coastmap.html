{% extends "layout.html" %}

{% block title %}
    Coast Map
{% endblock %}

{% block main %}
<div class="panel-body">
    
    <div class="row">
        
        <div id="setElev" class="form-group form-inline" >
            <label>Simulated sea level (-/+):</label>
        <input class="form-control" type="text" id="elev" style="width:100px;" value="0" />
        <button class="btn btn-warning" style="width:100px;" type="button" onclick="setElev(document.getElementById('elev').value);">Set</button>&nbsp;&nbsp;<b><span id="curElev" style="color:red;"></span><span style="color:red;"> meter.</span></b><br />
        </div>
                
    </div>

    <div class="row">
        
        <form action="/amisafe" method="post">
            <label>Check location: </label>
            <input class="form-control" autocomplete="off" id="amisafe" autofocus name="coord" value="19.090866, 72.831018" style="width:150px;" type="text">
            <button id="amisafeEntry" class="btn btn-warning" style="width:100px;" type="submit">Am I Safe</button>
        </form>
                
    </div>

    <div id="mapPanel" class="col-md-7">
        <div style="position:relative;">
            <div id="map_canvas" style="width:100%;height:600px;">
            </div>
            <div id="basemaps-wrapper" class="leaflet-bar">
                <select id="basemaps" ></select>
            </div>
        </div>
    </div>

    <div><input class="styled" type="text" id="link" style="width:95%"/></p>
    <br />
    </div>
    
    <div class="rowlegend">
        <div class="column">
            <h3 class="panel-title"><b>Legend</b></h3>
            <img src='data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7' id="legend">
        </div>
        <!-- <div class="column">
            <h4 class="panel-title"><b>Description</b></h4>
            <p id="legend_desc">OpenStreetMap - geospatial data which features roads and street data</p>
            <div class="landuselegend"></div>
        </div> -->
        
    </div>
    
{% endblock %}

{% block javascript %}
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <!-- <script src="/bootstrap-3.3.7-dist/js/bootstrap.min.js"></script> -->
    
    <script>
        var autoPopup = false;
        if (autoPopup)
            startAutoPopup();
        function startAutoPopup(){
            setTimeout(function () {
                $('#myModal').modal();
            }, 300000);
        }
    </script>
    
    <script>
        /* esri-leaflet-geocoder - v2.3.2 - Tue Nov 12 2019 12:54:26 GMT-0600 (Central Standard Time)
     * Copyright (c) 2019 Environmental Systems Research Institute, Inc.
     * Apache-2.0 */
        !function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports, require("leaflet"), require("esri-leaflet")) : "function" == typeof define && define.amd ? define(["exports", "leaflet", "esri-leaflet"], t) : t((e.L = e.L || {}, e.L.esri = e.L.esri || {}, e.L.esri.Geocoding = {}), e.L, e.L.esri) }(this, function (e, t, s) { "use strict"; function i(e) { return new p(e) } function o(e) { return new f(e) } function r(e) { return new v(e) } function n(e) { return new _(e) } function a(e, t) { return new m(e, t) } function l(e) { return new y(e) } function u(e) { return new x(e) } function h(e) { return new b(e) } function d(e) { return new S(e) } function c(e) { return new C(e) } var g = "https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/", p = s.Task.extend({ path: "findAddressCandidates", params: { outSr: 4326, forStorage: !1, outFields: "*", maxLocations: 20 }, setters: { address: "address", neighborhood: "neighborhood", city: "city", subregion: "subregion", region: "region", postal: "postal", country: "country", text: "singleLine", category: "category", token: "token", key: "magicKey", fields: "outFields", forStorage: "forStorage", maxLocations: "maxLocations", countries: "sourceCountry" }, initialize: function (e) { e = e || {}, e.url = e.url || g, s.Task.prototype.initialize.call(this, e) }, within: function (e) { return e = t.latLngBounds(e), this.params.searchExtent = s.Util.boundsToExtent(e), this }, nearby: function (e, s) { var i = t.latLng(e); return this.params.location = i.lng + "," + i.lat, this.params.distance = Math.min(Math.max(s, 2e3), 5e4), this }, run: function (e, t) { return this.options.customParam && (this.params[this.options.customParam] = this.params.singleLine, delete this.params.singleLine), this.request(function (s, i) { var o = this._processGeocoderResponse, r = s ? void 0 : o(i); e.call(t, s, { results: r }, i) }, this) }, _processGeocoderResponse: function (e) { for (var i = [], o = 0; o < e.candidates.length; o++) { var r = e.candidates[o]; if (r.extent) var n = s.Util.extentToBounds(r.extent); i.push({ text: r.address, bounds: n, score: r.score, latlng: t.latLng(r.location.y, r.location.x), properties: r.attributes }) } return i } }), f = s.Task.extend({ path: "reverseGeocode", params: { outSR: 4326, returnIntersection: !1 }, setters: { distance: "distance", language: "langCode", intersection: "returnIntersection" }, initialize: function (e) { e = e || {}, e.url = e.url || g, s.Task.prototype.initialize.call(this, e) }, latlng: function (e) { var s = t.latLng(e); return this.params.location = s.lng + "," + s.lat, this }, run: function (e, s) { return this.request(function (i, o) { var r; r = i ? void 0 : { latlng: t.latLng(o.location.y, o.location.x), address: o.address }, e.call(s, i, r, o) }, this) } }), v = s.Task.extend({ path: "suggest", params: {}, setters: { text: "text", category: "category", countries: "countryCode", maxSuggestions: "maxSuggestions" }, initialize: function (e) { e = e || {}, e.url || (e.url = g, e.supportsSuggest = !0), s.Task.prototype.initialize.call(this, e) }, within: function (e) { e = t.latLngBounds(e), e = e.pad(.5); var i = e.getCenter(), o = e.getNorthWest(); return this.params.location = i.lng + "," + i.lat, this.params.distance = Math.min(Math.max(i.distanceTo(o), 2e3), 5e4), this.params.searchExtent = s.Util.boundsToExtent(e), this }, nearby: function (e, s) { var i = t.latLng(e); return this.params.location = i.lng + "," + i.lat, this.params.distance = Math.min(Math.max(s, 2e3), 5e4), this }, run: function (e, t) { if (this.options.supportsSuggest) return this.request(function (s, i) { e.call(t, s, i, i) }, this); console.warn("this geocoding service does not support asking for suggestions") } }), _ = s.Service.extend({ initialize: function (e) { e = e || {}, e.url ? (s.Service.prototype.initialize.call(this, e), this._confirmSuggestSupport()) : (e.url = g, e.supportsSuggest = !0, s.Service.prototype.initialize.call(this, e)) }, geocode: function () { return i(this) }, reverse: function () { return o(this) }, suggest: function () { return r(this) }, _confirmSuggestSupport: function () { this.metadata(function (e, t) { e || (t.capabilities && t.capabilities.indexOf("Suggest") > -1 ? this.options.supportsSuggest = !0 : this.options.supportsSuggest = !1, this.options.customParam = t.singleLineAddressField.name) }, this) } }), m = t.Evented.extend({ options: { zoomToResult: 0, useMapBounds: 12, searchBounds: null }, initialize: function (e, s) { if (t.Util.setOptions(this, s), this._control = e, !s || !s.providers || !s.providers.length) throw new Error("You must specify at least one provider"); this._providers = s.providers }, _geocode: function (e, s, i) { var o, r = 0, n = [], a = t.Util.bind(function (t, s) { r-- , t || (s && (n = n.concat(s)), r <= 0 && (o = this._boundsFromResults(n), this.fire("results", { results: n, bounds: o, latlng: o ? o.getCenter() : void 0, text: e }, !0), this.options.zoomToResult && o && this._control._map.fitBounds(o), this.fire("load"))) }, this); if (s) r++ , i.results(e, s, this._searchBounds(), a); else for (var l = 0; l < this._providers.length; l++)r++ , this._providers[l].results(e, s, this._searchBounds(), a) }, _suggest: function (e) { var s = this._providers.length, i = 0, o = t.Util.bind(function (e, o) { return t.Util.bind(function (t, r) { if (s -= 1, i += r.length, t) return this._control._clearProviderSuggestions(o), void this._control._finalizeSuggestions(s, i); if (r.length) for (var n = 0; n < r.length; n++)r[n].provider = o; else this._control._renderSuggestions(r); o._lastRender !== e && this._control._clearProviderSuggestions(o), r.length && this._control._input.value === e && (o._lastRender = e, this._control._renderSuggestions(r)), this._control._finalizeSuggestions(s, i) }, this) }, this); this._pendingSuggestions = []; for (var r = 0; r < this._providers.length; r++) { var n = this._providers[r], a = n.suggestions(e, this._searchBounds(), o(e, n)); this._pendingSuggestions.push(a) } }, _searchBounds: function () { return null !== this.options.searchBounds ? this.options.searchBounds : !1 === this.options.useMapBounds ? null : !0 === this.options.useMapBounds ? this._control._map.getBounds() : this.options.useMapBounds <= this._control._map.getZoom() ? this._control._map.getBounds() : null }, _boundsFromResults: function (e) { if (e.length) { for (var s = t.latLngBounds([0, 0], [0, 0]), i = [], o = [], r = e.length - 1; r >= 0; r--) { var n = e[r]; o.push(n.latlng), n.bounds && n.bounds.isValid() && !n.bounds.equals(s) && i.push(n.bounds) } for (var a = t.latLngBounds(o), l = 0; l < i.length; l++)a.extend(i[l]); return a } }, _getAttribution: function () { for (var e = [], t = this._providers, s = 0; s < t.length; s++)t[s].options.attribution && e.push(t[s].options.attribution); return e.join(", ") } }), y = _.extend({ options: { label: "Places and Addresses", maxResults: 5 }, suggestions: function (e, t, s) { var i = this.suggest().text(e); return t && i.within(t), this.options.countries && i.countries(this.options.countries), this.options.categories && i.category(this.options.categories), i.maxSuggestions(this.options.maxResults), i.run(function (e, t, i) { var o = []; if (!e) for (; i.suggestions.length && o.length <= this.options.maxResults - 1;) { var r = i.suggestions.shift(); r.isCollection || o.push({ text: r.text, unformattedText: r.text, magicKey: r.magicKey }) } s(e, o) }, this) }, results: function (e, t, s, i) { var o = this.geocode().text(e); return t && o.key(t), o.maxLocations(this.options.maxResults), s && o.within(s), this.options.forStorage && o.forStorage(!0), this.options.countries && o.countries(this.options.countries), this.options.categories && o.category(this.options.categories), o.run(function (e, t) { i(e, t.results) }, this) } }), x = t.Control.extend({ includes: t.Evented.prototype, options: { position: "topleft", collapseAfterResult: !0, expanded: !1, allowMultipleResults: !0, placeholder: "Search for places or addresses", title: "Location Search" }, initialize: function (e) { t.Util.setOptions(this, e), e && e.providers && e.providers.length || (e || (e = {}), e.providers = [l()]), this._geosearchCore = a(this, e), this._geosearchCore._providers = e.providers, this._geosearchCore.addEventParent(this); for (var s = 0; s < this._geosearchCore._providers.length; s++)this._geosearchCore._providers[s].addEventParent(this); this._geosearchCore._pendingSuggestions = [], t.Control.prototype.initialize.call(this, e) }, _renderSuggestions: function (e) { var s; e.length > 0 && (this._suggestions.style.display = "block"); for (var i, o, r = [], n = 0; n < e.length; n++) { var a = e[n]; if (!o && this._geosearchCore._providers.length > 1 && s !== a.provider.options.label && (o = t.DomUtil.create("div", "geocoder-control-header", a.provider._contentsElement), o.textContent = a.provider.options.label, o.innerText = a.provider.options.label, s = a.provider.options.label), i || (i = t.DomUtil.create("ul", "geocoder-control-list", a.provider._contentsElement)), -1 === r.indexOf(a.text)) { var l = t.DomUtil.create("li", "geocoder-control-suggestion", i); l.innerHTML = a.text, l.provider = a.provider, l["data-magic-key"] = a.magicKey, l.unformattedText = a.unformattedText } else for (var u = 0; u < i.childNodes.length; u++)i.childNodes[u].innerHTML === a.text && (i.childNodes[u]["data-magic-key"] += "," + a.magicKey); r.push(a.text) } this.getPosition().indexOf("top") > -1 && (this._suggestions.style.maxHeight = this._map.getSize().y - this._suggestions.offsetTop - this._wrapper.offsetTop - 10 + "px"), this.getPosition().indexOf("bottom") > -1 && this._setSuggestionsBottomPosition() }, _setSuggestionsBottomPosition: function () { this._suggestions.style.maxHeight = this._map.getSize().y - this._map._controlCorners[this.getPosition()].offsetHeight - this._wrapper.offsetHeight + "px", this._suggestions.style.top = -this._suggestions.offsetHeight - this._wrapper.offsetHeight + 20 + "px" }, _boundsFromResults: function (e) { if (e.length) { for (var s = t.latLngBounds([0, 0], [0, 0]), i = [], o = [], r = e.length - 1; r >= 0; r--) { var n = e[r]; o.push(n.latlng), n.bounds && n.bounds.isValid() && !n.bounds.equals(s) && i.push(n.bounds) } for (var a = t.latLngBounds(o), l = 0; l < i.length; l++)a.extend(i[l]); return a } }, clear: function () { this._clearAllSuggestions(), this.options.collapseAfterResult && (this._input.value = "", this._lastValue = "", this._input.placeholder = "", t.DomUtil.removeClass(this._wrapper, "geocoder-control-expanded")), !this._map.scrollWheelZoom.enabled() && this._map.options.scrollWheelZoom && this._map.scrollWheelZoom.enable() }, _clearAllSuggestions: function () { this._suggestions.style.display = "none"; for (var e = 0; e < this.options.providers.length; e++)this._clearProviderSuggestions(this.options.providers[e]) }, _clearProviderSuggestions: function (e) { e._contentsElement.innerHTML = "" }, _finalizeSuggestions: function (e, s) { e || (t.DomUtil.removeClass(this._input, "geocoder-control-loading"), this.getPosition().indexOf("bottom") > -1 && this._setSuggestionsBottomPosition(), s || this._clearAllSuggestions()) }, _setupClick: function () { t.DomUtil.addClass(this._wrapper, "geocoder-control-expanded"), this._input.focus() }, disable: function () { this._input.disabled = !0, t.DomUtil.addClass(this._input, "geocoder-control-input-disabled"), t.DomEvent.removeListener(this._wrapper, "click", this._setupClick, this) }, enable: function () { this._input.disabled = !1, t.DomUtil.removeClass(this._input, "geocoder-control-input-disabled"), t.DomEvent.addListener(this._wrapper, "click", this._setupClick, this) }, getAttribution: function () { for (var e = [], t = 0; t < this._providers.length; t++)this._providers[t].options.attribution && e.push(this._providers[t].options.attribution); return e.join(", ") }, geocodeSuggestion: function (e) { var t = e.target || e.srcElement; t.classList.contains("geocoder-control-suggestions") || t.classList.contains("geocoder-control-header") || (t.classList.length < 1 && (t = t.parentNode), this._geosearchCore._geocode(t.unformattedText, t["data-magic-key"], t.provider), this.clear()) }, onAdd: function (e) { s.Util.setEsriAttribution(e), this._map = e, this._wrapper = t.DomUtil.create("div", "geocoder-control"), this._input = t.DomUtil.create("input", "geocoder-control-input leaflet-bar", this._wrapper), this._input.title = this.options.title, this.options.expanded && (t.DomUtil.addClass(this._wrapper, "geocoder-control-expanded"), this._input.placeholder = this.options.placeholder), this._suggestions = t.DomUtil.create("div", "geocoder-control-suggestions leaflet-bar", this._wrapper); for (var i = 0; i < this.options.providers.length; i++)this.options.providers[i]._contentsElement = t.DomUtil.create("div", null, this._suggestions); var o = this._geosearchCore._getAttribution(); return e.attributionControl && e.attributionControl.addAttribution(o), t.DomEvent.addListener(this._input, "focus", function (e) { this._input.placeholder = this.options.placeholder, t.DomUtil.addClass(this._wrapper, "geocoder-control-expanded") }, this), t.DomEvent.addListener(this._wrapper, "click", this._setupClick, this), t.DomEvent.addListener(this._suggestions, "mousedown", this.geocodeSuggestion, this), t.DomEvent.addListener(this._input, "blur", function (e) { this.clear() }, this), t.DomEvent.addListener(this._input, "keydown", function (e) { var s = (e.target || e.srcElement).value; t.DomUtil.addClass(this._wrapper, "geocoder-control-expanded"); for (var i, o = this._suggestions.querySelectorAll(".geocoder-control-suggestion"), r = this._suggestions.querySelectorAll(".geocoder-control-selected")[0], n = 0; n < o.length; n++)if (o[n] === r) { i = n; break } switch (e.keyCode) { case 13: r ? (this._input.value = r.innerText, this._geosearchCore._geocode(r.unformattedText, r["data-magic-key"], r.provider), this.clear()) : this.options.allowMultipleResults && s.length >= 2 ? (this._geosearchCore._geocode(this._input.value, void 0), this.clear()) : 1 === o.length ? (t.DomUtil.addClass(o[0], "geocoder-control-selected"), this._geosearchCore._geocode(o[0].innerHTML, o[0]["data-magic-key"], o[0].provider)) : (this.clear(), this._input.blur()), t.DomEvent.preventDefault(e); break; case 38: r && t.DomUtil.removeClass(r, "geocoder-control-selected"); var a = o[i - 1]; r && a ? t.DomUtil.addClass(a, "geocoder-control-selected") : t.DomUtil.addClass(o[o.length - 1], "geocoder-control-selected"), t.DomEvent.preventDefault(e); break; case 40: r && t.DomUtil.removeClass(r, "geocoder-control-selected"); var l = o[i + 1]; r && l ? t.DomUtil.addClass(l, "geocoder-control-selected") : t.DomUtil.addClass(o[0], "geocoder-control-selected"), t.DomEvent.preventDefault(e); break; default: for (var u = 0; u < this._geosearchCore._pendingSuggestions.length; u++) { var h = this._geosearchCore._pendingSuggestions[u]; h && h.abort && !h.id && h.abort() } } }, this), t.DomEvent.addListener(this._input, "keyup", t.Util.throttle(function (e) { var s = e.which || e.keyCode, i = (e.target || e.srcElement).value; return i.length < 2 ? (this._lastValue = this._input.value, this._clearAllSuggestions(), void t.DomUtil.removeClass(this._input, "geocoder-control-loading")) : 27 === s ? void this._clearAllSuggestions() : void (13 !== s && 38 !== s && 40 !== s && this._input.value !== this._lastValue && (this._lastValue = this._input.value, t.DomUtil.addClass(this._input, "geocoder-control-loading"), this._geosearchCore._suggest(i))) }, 50, this), this), t.DomEvent.disableClickPropagation(this._wrapper), t.DomEvent.addListener(this._suggestions, "mouseover", function (t) { e.scrollWheelZoom.enabled() && e.options.scrollWheelZoom && e.scrollWheelZoom.disable() }), t.DomEvent.addListener(this._suggestions, "mouseout", function (t) { !e.scrollWheelZoom.enabled() && e.options.scrollWheelZoom && e.scrollWheelZoom.enable() }), this._geosearchCore.on("load", function (e) { t.DomUtil.removeClass(this._input, "geocoder-control-loading"), this.clear(), this._input.blur() }, this), this._wrapper } }), b = s.FeatureLayerService.extend({ options: { label: "Feature Layer", maxResults: 5, bufferRadius: 1e3, formatSuggestion: function (e) { return e.properties[this.options.searchFields[0]] } }, initialize: function (e) { s.FeatureLayerService.prototype.initialize.call(this, e), "string" == typeof this.options.searchFields && (this.options.searchFields = [this.options.searchFields]), this._suggestionsQuery = this.query(), this._resultsQuery = this.query() }, suggestions: function (e, t, s) { var i = this._suggestionsQuery.where(this._buildQuery(e)).returnGeometry(!1); return t && i.intersects(t), this.options.idField && i.fields([this.options.idField].concat(this.options.searchFields)), i.run(function (e, t, i) { if (e) s(e, []); else { this.options.idField = i.objectIdFieldName; for (var o = [], r = t.features.length - 1; r >= 0; r--) { var n = t.features[r]; o.push({ text: this.options.formatSuggestion.call(this, n), unformattedText: n.properties[this.options.searchFields[0]], magicKey: n.id }) } s(e, o.slice(0, this.options.maxResults)) } }, this) }, results: function (e, s, i, o) { var r = this._resultsQuery; return s ? (delete r.params.where, r.featureIds([s])) : r.where(this._buildQuery(e)), i && r.within(i), r.run(t.Util.bind(function (e, t) { for (var s = [], i = 0; i < t.features.length; i++) { var r = t.features[i]; if (r) { var n = this._featureBounds(r), a = { latlng: n.getCenter(), bounds: n, text: this.options.formatSuggestion.call(this, r), properties: r.properties, geojson: r }; s.push(a), delete this._resultsQuery.params.objectIds } } o(e, s) }, this)) }, orderBy: function (e, t) { this._suggestionsQuery.orderBy(e, t) }, _buildQuery: function (e) { for (var t = [], s = this.options.searchFields.length - 1; s >= 0; s--) { var i = 'upper("' + this.options.searchFields[s] + '")'; t.push(i + " LIKE upper('%" + e + "%')") } return this.options.where ? this.options.where + " AND (" + t.join(" OR ") + ")" : t.join(" OR ") }, _featureBounds: function (e) { var s = t.geoJson(e); if ("Point" === e.geometry.type) { var i = s.getBounds().getCenter(), o = this.options.bufferRadius / 40075017 * 360 / Math.cos(180 / Math.PI * i.lat), r = this.options.bufferRadius / 40075017 * 360; return t.latLngBounds([i.lat - r, i.lng - o], [i.lat + r, i.lng + o]) } return s.getBounds() } }), S = s.MapService.extend({ options: { layers: [0], label: "Map Service", bufferRadius: 1e3, maxResults: 5, formatSuggestion: function (e) { return e.properties[e.displayFieldName] + " <small>" + e.layerName + "</small>" } }, initialize: function (e) { s.MapService.prototype.initialize.call(this, e), this._getIdFields() }, suggestions: function (e, t, s) { return this.find().text(e).fields(this.options.searchFields).returnGeometry(!1).layers(this.options.layers).run(function (e, t, i) { var o = []; if (!e) { var r = Math.min(this.options.maxResults, t.features.length); i.results = i.results.reverse(); for (var n = 0; n < r; n++) { var a = t.features[n], l = i.results[n], u = l.layerId, h = this._idFields[u]; a.layerId = u, a.layerName = this._layerNames[u], a.displayFieldName = this._displayFields[u], h && o.push({ text: this.options.formatSuggestion.call(this, a), unformattedText: a.properties[a.displayFieldName], magicKey: l.attributes[h] + ":" + u }) } } s(e, o.reverse()) }, this) }, results: function (e, t, s, i) { var o, r = []; if (t) { var n = t.split(":")[0], a = t.split(":")[1]; o = this.query().layer(a).featureIds(n) } else o = this.find().text(e).fields(this.options.searchFields).layers(this.options.layers); return o.run(function (e, t, s) { if (!e) { s.results && (s.results = s.results.reverse()); for (var o = 0; o < t.features.length; o++) { var n = t.features[o]; if (a = a || s.results[o].layerId, n && void 0 !== a) { var l = this._featureBounds(n); n.layerId = a, n.layerName = this._layerNames[a], n.displayFieldName = this._displayFields[a]; var u = { latlng: l.getCenter(), bounds: l, text: this.options.formatSuggestion.call(this, n), properties: n.properties, geojson: n }; r.push(u) } } } i(e, r.reverse()) }, this) }, _featureBounds: function (e) { var s = t.geoJson(e); if ("Point" === e.geometry.type) { var i = s.getBounds().getCenter(), o = this.options.bufferRadius / 40075017 * 360 / Math.cos(180 / Math.PI * i.lat), r = this.options.bufferRadius / 40075017 * 360; return t.latLngBounds([i.lat - r, i.lng - o], [i.lat + r, i.lng + o]) } return s.getBounds() }, _layerMetadataCallback: function (e) { return t.Util.bind(function (t, s) { if (!t) { this._displayFields[e] = s.displayField, this._layerNames[e] = s.name; for (var i = 0; i < s.fields.length; i++) { var o = s.fields[i]; if ("esriFieldTypeOID" === o.type) { this._idFields[e] = o.name; break } } } }, this) }, _getIdFields: function () { this._idFields = {}, this._displayFields = {}, this._layerNames = {}; for (var e = 0; e < this.options.layers.length; e++) { var t = this.options.layers[e]; this.get(t, {}, this._layerMetadataCallback(t)) } } }), C = _.extend({ options: { label: "Geocode Server", maxResults: 5 }, suggestions: function (e, t, s) { if (this.options.supportsSuggest) { var i = this.suggest().text(e); return t && i.within(t), i.run(function (e, t, i) { var o = []; if (!e) for (; i.suggestions.length && o.length <= this.options.maxResults - 1;) { var r = i.suggestions.shift(); r.isCollection || o.push({ text: r.text, unformattedText: r.text, magicKey: r.magicKey }) } s(e, o) }, this) } return s(void 0, []), !1 }, results: function (e, t, s, i) { var o = this.geocode().text(e); return t && o.key(t), o.maxLocations(this.options.maxResults), s && o.within(s), o.run(function (e, t) { i(e, t.results) }, this) } }); e.VERSION = "2.3.2", e.Geocode = p, e.geocode = i, e.ReverseGeocode = f, e.reverseGeocode = o, e.Suggest = v, e.suggest = r, e.GeocodeService = _, e.geocodeService = n, e.Geosearch = x, e.geosearch = u, e.GeosearchCore = m, e.geosearchCore = a, e.ArcgisOnlineProvider = y, e.arcgisOnlineProvider = l, e.FeatureLayerProvider = b, e.featureLayerProvider = h, e.MapServiceProvider = S, e.mapServiceProvider = d, e.GeocodeServiceProvider = C, e.geocodeServiceProvider = c, e.WorldGeocodingServiceUrl = g, Object.defineProperty(e, "__esModule", { value: !0 }) });
    //# sourceMappingURL=esri-leaflet-geocoder.js.map
    </script>

    <script>
        // SSP GPP
    String.prototype.format = function () {
        var i = 0, args = arguments;
        return this.replace(/{}/g, function () {
            return typeof args[i] != 'undefined' ? args[i++] : '';
        });
    };

    var ssp_gpp = {};
    var uri_base = 'https://sedac.ciesin.columbia.edu/geoserver/ows?service=WMS&request=GetLegendGraphic&format=image/png&width=20&height=20&layer=';
    
    for (var i = 1; i <= 5; i++) {
        var ssp_type = 'ssp{}'.format(i);
        var wms_name_2050 = 'popdynamics:popdynamics-pop-projection-ssp-2010-2100_{}-2050-total-population'.format(ssp_type)
        var wms_name_2100 = 'popdynamics:popdynamics-pop-projection-ssp-2010-2100_{}-2100-total-population'.format(ssp_type)
        ssp_gpp[ssp_type] = {"2050": {'name':wms_name_2050,'uri':uri_base+wms_name_2050+'&'},
                            "2100": {'name':wms_name_2100,'uri':uri_base+wms_name_2100+'&'}};
    }
    console.log(ssp_gpp);

    //legend data
    var legendurl = 'http://akshaykore.github.io/mumdata/layers/legend/';
    var urlbase = 'http://akshaykore.github.io/mumdata/layers/';

    var legenddata = [
        
        {
            "id" : 0,
            "name":"Residential",
            "type":"static",
            "url":urlbase + "residential.svg",
            "legend": legendurl + "residential.jpg",
            "visible":false,
            "author":"MCGM",
            "value":true
        },
        
        {
            "id" : 1,
            "name":"Commercial",
            "type":"static",
            "url":urlbase + 'commercial.svg',
            "legend": legendurl + "commercial.jpg",
            "visible":false,
            "author":"MCGM",
            "value":true
        },
        
        {   "id" : 4,
            "name":"Industrial",
            "type":"static",
            "url":urlbase + 'industrial.svg',
            "legend": legendurl + "industrial.jpg",
            "visible":false,
            "author":"MCGM",
            "value":true
        },
        
        {   "id" : 25,
            "name":"Slum Areas",
            "type":"static",
            "url":urlbase + 'slum.svg',
            "legend": legendurl + "slum.jpg",
            "visible":false,
            "author":"MCGM",
            "value":true
        }

    ];

    var ssp5_2100_e1 = {
        "x-0_y-1_z-3": {
            "url": "https://live.staticflickr.com/65535/53028209306_2a19e504e5_o.png",
            "UL": [
            79.17133464081945,
            -180.0
            ],
            "LR": [
            66.51326044311186,
            -135.0
            ]
        },
        "x-0_y-2_z-3": {
            "url": "https://live.staticflickr.com/65535/53028598055_46d5fc26be_o.png",
            "UL": [
            66.51326044311186,
            -180.0
            ],
            "LR": [
            40.97989806962013,
            -135.0
            ]
        },
        "x-0_y-3_z-3": {
            "url": "https://live.staticflickr.com/65535/53028383054_81d4eb4c40_o.png",
            "UL": [
            40.97989806962013,
            -180.0
            ],
            "LR": [
            0.0,
            -135.0
            ]
        },
        "x-1_y-1_z-3": {
            "url": "https://live.staticflickr.com/65535/53028383019_da4a4172da_o.png",
            "UL": [
            79.17133464081945,
            -135.0
            ],
            "LR": [
            66.51326044311186,
            -90.0
            ]
        },
        "x-1_y-2_z-3": {
            "url": "https://live.staticflickr.com/65535/53028209286_8891e2632b_o.png",
            "UL": [
            66.51326044311186,
            -135.0
            ],
            "LR": [
            40.97989806962013,
            -90.0
            ]
        },
        "x-1_y-3_z-3": {
            "url": "https://live.staticflickr.com/65535/53028209276_a238ea3c10_o.png",
            "UL": [
            40.97989806962013,
            -135.0
            ],
            "LR": [
            0.0,
            -90.0
            ]
        },
        "x-2_y-1_z-3": {
            "url": "https://live.staticflickr.com/65535/53027625147_c84b5d1e55_o.png",
            "UL": [
            79.17133464081945,
            -90.0
            ],
            "LR": [
            66.51326044311186,
            -45.0
            ]
        },
        "x-2_y-2_z-3": {
            "url": "https://live.staticflickr.com/65535/53027625142_25c22fdffe_o.png",
            "UL": [
            66.51326044311186,
            -90.0
            ],
            "LR": [
            40.97989806962013,
            -45.0
            ]
        },
        "x-2_y-3_z-3": {
            "url": "https://live.staticflickr.com/65535/53028598020_922dc30c3f_o.png",
            "UL": [
            40.97989806962013,
            -90.0
            ],
            "LR": [
            0.0,
            -45.0
            ]
        },
        "x-2_y-4_z-3": {
            "url": "https://live.staticflickr.com/65535/53027625132_31092abb6f_o.png",
            "UL": [
            0.0,
            -90.0
            ],
            "LR": [
            -40.97989806962013,
            -45.0
            ]
        },
        "x-2_y-5_z-3": {
            "url": "https://live.staticflickr.com/65535/53028209281_0cb3e182fb_o.png",
            "UL": [
            -40.97989806962013,
            -90.0
            ],
            "LR": [
            -66.51326044311186,
            -45.0
            ]
        },
        "x-3_y-1_z-3": {
            "url": "https://live.staticflickr.com/65535/53028382984_243d97fa3a_o.png",
            "UL": [
            79.17133464081945,
            -45.0
            ],
            "LR": [
            66.51326044311186,
            0.0
            ]
        },
        "x-3_y-2_z-3": {
            "url": "https://live.staticflickr.com/65535/53028382989_bc54d17bfa_o.png",
            "UL": [
            66.51326044311186,
            -45.0
            ],
            "LR": [
            40.97989806962013,
            0.0
            ]
        },
        "x-3_y-3_z-3": {
            "url": "https://live.staticflickr.com/65535/53028695588_a83325726c_o.png",
            "UL": [
            40.97989806962013,
            -45.0
            ],
            "LR": [
            0.0,
            0.0
            ]
        },
        "x-3_y-4_z-3": {
            "url": "https://live.staticflickr.com/65535/53028597935_6d37e9afd7_o.png",
            "UL": [
            0.0,
            -45.0
            ],
            "LR": [
            -40.97989806962013,
            0.0
            ]
        },
        "x-4_y-1_z-3": {
            "url": "https://live.staticflickr.com/65535/53028209216_a0b4f2e581_o.png",
            "UL": [
            79.17133464081945,
            0.0
            ],
            "LR": [
            66.51326044311186,
            45.0
            ]
        },
        "x-4_y-2_z-3": {
            "url": "https://live.staticflickr.com/65535/53028597925_cb2eea632b_o.png",
            "UL": [
            66.51326044311186,
            0.0
            ],
            "LR": [
            40.97989806962013,
            45.0
            ]
        },
        "x-4_y-3_z-3": {
            "url": "https://live.staticflickr.com/65535/53028209146_7e540c5111_o.png",
            "UL": [
            40.97989806962013,
            0.0
            ],
            "LR": [
            0.0,
            45.0
            ]
        },
        "x-4_y-4_z-3": {
            "url": "https://live.staticflickr.com/65535/53028209131_057e88f49b_o.png",
            "UL": [
            0.0,
            0.0
            ],
            "LR": [
            -40.97989806962013,
            45.0
            ]
        },
        "x-5_y-1_z-3": {
            "url": "https://live.staticflickr.com/65535/53028597885_e5083cbf07_o.png",
            "UL": [
            79.17133464081945,
            45.0
            ],
            "LR": [
            66.51326044311186,
            90.0
            ]
        },
        "x-5_y-2_z-3": {
            "url": "https://live.staticflickr.com/65535/53028209136_83e8b9d39a_o.png",
            "UL": [
            66.51326044311186,
            45.0
            ],
            "LR": [
            40.97989806962013,
            90.0
            ]
        },
        "x-5_y-3_z-3": {
            "url": "https://live.staticflickr.com/65535/53028695528_f43846c42d_o.png",
            "UL": [
            40.97989806962013,
            45.0
            ],
            "LR": [
            0.0,
            90.0
            ]
        },
        "x-5_y-4_z-3": {
            "url": "https://live.staticflickr.com/65535/53027625082_20dc53c3d1_o.png",
            "UL": [
            0.0,
            45.0
            ],
            "LR": [
            -40.97989806962013,
            90.0
            ]
        },
        "x-6_y-1_z-3": {
            "url": "https://live.staticflickr.com/65535/53028382939_2f14ab785d_o.png",
            "UL": [
            79.17133464081945,
            90.0
            ],
            "LR": [
            66.51326044311186,
            135.0
            ]
        },
        "x-6_y-2_z-3": {
            "url": "https://live.staticflickr.com/65535/53027625032_f15eb1e7d0_o.png",
            "UL": [
            66.51326044311186,
            90.0
            ],
            "LR": [
            40.97989806962013,
            135.0
            ]
        },
        "x-6_y-3_z-3": {
            "url": "https://live.staticflickr.com/65535/53028382889_7e6b69bd8d_o.png",
            "UL": [
            40.97989806962013,
            90.0
            ],
            "LR": [
            0.0,
            135.0
            ]
        },
        "x-6_y-4_z-3": {
            "url": "https://live.staticflickr.com/65535/53028597850_126701364d_o.png",
            "UL": [
            0.0,
            90.0
            ],
            "LR": [
            -40.97989806962013,
            135.0
            ]
        },
        "x-7_y-1_z-3": {
            "url": "https://live.staticflickr.com/65535/53028597840_7028956860_o.png",
            "UL": [
            79.17133464081945,
            135.0
            ],
            "LR": [
            66.51326044311186,
            180.0
            ]
        },
        "x-7_y-2_z-3": {
            "url": "https://live.staticflickr.com/65535/53028382874_8bbab93587_o.png",
            "UL": [
            66.51326044311186,
            135.0
            ],
            "LR": [
            40.97989806962013,
            180.0
            ]
        },
        "x-7_y-3_z-3": {
            "url": "https://live.staticflickr.com/65535/53028597820_d045b0610b_o.png",
            "UL": [
            40.97989806962013,
            135.0
            ],
            "LR": [
            0.0,
            180.0
            ]
        },
        "x-7_y-4_z-3": {
            "url": "https://live.staticflickr.com/65535/53028695453_3bf4b5837c_o.png",
            "UL": [
            0.0,
            135.0
            ],
            "LR": [
            -40.97989806962013,
            180.0
            ]
        },
        "x-7_y-5_z-3": {
            "url": "https://live.staticflickr.com/65535/53028209066_a9d3bac04c_o.png",
            "UL": [
            -40.97989806962013,
            135.0
            ],
            "LR": [
            -66.51326044311186,
            180.0
            ]
        }
        };
    
    var leaflet_color_icon = {
        'yellow': "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-yellow.png",
        'orange': "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-orange.png",
        'red': "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png"
    };

    var mumbai_vulnerability_map = {
        'vulnerability_index': {
            "url": "https://live.staticflickr.com/65535/53031989345_4670c818d6_o.png",
            "UL": [19.343, 72.672],
            "LR": [18.832, 73.1697]
        }
    };

    (function() {
        var elm = document.getElementById('basemaps'),
            df = document.createDocumentFragment();
        // var options_list = ['OpenStreetMap',"OpenTopoMap",'Mumbai Population Density',"Crowd-Sourced Photos",'Land use','Mumbai vulnerability map','Land subsidence','Topography','Road network map','Historical flood map','Global vulnerability map'];
        var options_list = ['Basemap','Population density','Land use','Land subsidence','Topography','2005 Mumbai flood',"Crowd-Sourced Photos",'Vulnerability index', 'Vulnerability classification'];
        for (var j = 0; j < options_list.length; j++){
            var option = document.createElement('option');
            option.value = options_list[j];
            option.appendChild(document.createTextNode(options_list[j]));
            df.appendChild(option);
        }
            
        // for (var i = 1; i <= 5; i++) {
            
        //     var option = document.createElement('option');
        //     var ssp_type = 'ssp{}_{}'.format(i,2050);
        //     option.value = ssp_type;
        //     // option.value = ssp_gpp['ssp{}'.format(i)][2050];
        //     // console.log(ssp_gpp['ssp{}'.format(i)][2050]);
        //     option.appendChild(document.createTextNode(ssp_type));
        //     df.appendChild(option);

        //     var option = document.createElement('option');
        //     var ssp_type = 'ssp{}_{}'.format(i,2100);
        //     option.value = ssp_type;
        //     // option.value = ssp_gpp['ssp{}'.format(i)][2100];
        //     option.appendChild(document.createTextNode(ssp_type));
        //     df.appendChild(option);
            
        // }
        elm.appendChild(df);
    }());

    var lat, lng, intitZoom;
    
    lat = 20;
    lng = -10;
    initZoom = 3;
        
    var mapElem = document.getElementById('map_canvas');
    var map = L.map('map_canvas',
        {
            minZoom: 2,
            maxZoom: 15,
            fullscreenControl: true,
            maxBounds:L.latLngBounds(L.latLng(-90, -180), L.latLng(90, 180)),
            maxBoundsViscosity: 1.0
        });
    map.setView([lat, lng], initZoom);
    var elev = document.getElementById('elev').value;
    
    function onEachFeature(feature, layer) {
        // does this feature have a property named popupContent?
        if (feature.properties && feature.properties.popupContent) {
            var lon = parseFloat(feature.geometry.coordinates[0]).toFixed(3);
            var lat = parseFloat(feature.geometry.coordinates[1]).toFixed(3);
            console.log(lat,lon);
            layer.bindPopup(feature.properties.popupContent + "\nlat: {}, lon: {}".format(lat,lon));
            // layer.bindPopup(feature.properties.popupContent + '\n' + feature.geometry.coordinates);
        }
    }

    // add mumbai population density (2011)
    var mumbai_dict = JSON.parse('{{mumbai_dict | tojson}}');
    // get color depending on population density value
    function getColor(d) {
        return d > 90000 ? '#800026' :
            d > 50000  ? '#BD0026' :
            d > 40000  ? '#E31A1C' :
            d > 30000  ? '#FC4E2A' :
            d > 20000   ? '#FD8D3C' :
            d > 10000   ? '#FEB24C' :
            d > 5000   ? '#FED976' :
                        '#FFEDA0';
    };

      //extend Leaflet to create a GeoJSON layer from a TopoJSON file
      L.TopoJSON = L.GeoJSON.extend({
        addData: function (data) {
          var geojson, key;
          if (data.type === "Topology") {
            for (key in data.objects) {
              if (data.objects.hasOwnProperty(key)) {
                geojson = topojson.feature(data, data.objects[key]);
                L.GeoJSON.prototype.addData.call(this, geojson);
              }
            }
            return this;
          }
          L.GeoJSON.prototype.addData.call(this, data);
          return this;
        }
      });

      

      L.topoJson = function (data, options) {
        return new L.TopoJSON(data, options);
      };

    //create an empty geojson layer, 
    //create a different style for each individual feature
    //with a style and a popup on click
    var geojson = L.topoJson(null, {
        style: function(feature){
        return {
            color: "#000",
            opacity: 1,
            weight: 1,
            //fillColor: getColor(feature.properties.density),
            fillColor: getColor(mumbai_dict[feature.properties.name].TOT_P_DEN),
            fillOpacity: 0.8
        }
        },
        //The onEachFeature option is a function that gets called on each feature before adding it to a GeoJSON layer. 
        //A common reason to use this option is to attach a popup to features when they are clicked.
        onEachFeature: function(feature, layer) {
        layer.bindPopup('<p><b>'+mumbai_dict[feature.properties.name].Ward_Names+'</b><br>'+mumbai_dict[feature.properties.name].TOT_P_DEN+' people/km<sup>2</sup></p>')
        }
    });//.addTo(map); //TODO: ADD SET BOUNDS TO MAP FOR ZOOM IN, AND EVENT LISTENER
    //   map.fitBounds(geojson.getBounds());
    //fill: #317581;
    //define a function to get and parse geojson from URL
    async function getGeoData(url) {
        let response = await fetch(url);
        let data = await response.json();
        console.log(data)
        return data;
    }

    // var layer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
    var layer = L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}.png').addTo(map);
    var mumbai_popn_density = false; //initialised to undefined by default
    var mumbai_landuse = false;
    var global_vulnerability_map = false;
    let crowd_sourced_photos = [];
    var vulnerability_map;
    var svg_landuse;
    var layerLabels;

    document
        .querySelector('#basemaps')
        .addEventListener('change', function (e) {
            //$('#myModal').modal();
            //e.target.value = 'OpenStreetMap';
            
            var basemap = e.target.value;
            setBasemap(basemap);
            updateLegend(basemap);
        });
    
    var isColorFloodMap;
    var fmTileUrl = 'https://www.floodmap.net/getFMTile.ashx?x={x}&y={y}&z={z}&e=';
    var floodLayer = L.tileLayer(fmTileUrl + elev, {
        attribution: 'Â© <a href="https://openstreetmap.org/copyright">OpenStreetMap</a> contributors,<a href="https://www.mapzen.com/rights">Mapzen</a>, <a href = "https://floodmap.net">Floodmap.net</a>, <a href = "https://github.com/akshaykore/mumdata/">Akshay Kore</a>',
        opacity: 0.5
    })
    // var searchControl = L.esri.Geocoding.geosearch({ useMapBounds: 20, expanded:true }).addTo(map);

    var resultsL = L.layerGroup().addTo(map);
    var marker;

    function addMarker(point) {
        if (marker != undefined) {
            map.removeLayer(marker);
        };
        point = L.latLng(Math.round(point.lat * 1000000) / 1000000, Math.round(point.lng * 1000000) / 1000000);
        marker = L.marker(point);
        resultsL.addLayer(marker);
        var popup = L.popup();
        // popup.setContent('<b>Please Wait!</b><br>Getting Elevation Information...');
        popup.setContent('<b>Latitude: '+point.lat + '<br>Longitude: '+ point.lng +'</b>');
        marker.bindPopup(popup);
        marker.openPopup();
        getElevation(popup, point);
    }

    function getElevation(popup, point) {
        vZoom = map.getZoom();
        $.getJSON('/pro/elevationmap/getelevation.ashx?lat=' + point.lat + '&lon=' + point.lng + '&zoom=' + vZoom, function (data) {
            var popupHtml = "<b>Latitude: " + point.lat + "<br>Longitude: " + point.lng + "</b><br>" + "<p id='elevContent' style='padding-bottom:0px;'>" + getElevContent(data.value) + "</p>";
            popElev = data.value;
            ga('send', 'event', 'Elevation', 'elevfound');
            // popupHtml = popupHtml + "<br><br><a style='font-size:1.2em;' target='_blank' href = '/3DFloodMap/' >ðŸ‘‰ <b>View in 3D</b></a >";
            popup.setContent(popupHtml);
        });
      }

    map.on("click", function (e) {
        ga('send', 'event', 'Location', 'locclick');
        addMarker(e.latlng);
    })

    map.on("zoom", function (e) {
        updateLink();
        updateAMISAFE();
    })

    map.on("move", function (e) {
        updateLink();
        updateAMISAFE();
    })

    
    //codeLatLng(marker.getPosition(), true);
    setElev(elev,false);
        
        

    function setElev(elevS, event=true) {
        if (isNaN(elevS)) {
            alert("Please enter only numeric value!");
            return;
        }
        elevS = Math.round(elevS);
        document.getElementById("elev").value = elevS;
        elev = elevS;
        updateLink();
        //infowindow.close();
        refresh();
        if (event)
            ga('send', 'event', 'Elevation', 'setelev');
    }

    function refresh() {
        //map.overlayMapTypes.setAt(0, floodMapType);
        document.getElementById("curElev").innerHTML = elev;
        if (isColorFloodMap)
            AddColorFloodMap();
        else
            floodLayer.setUrl(fmTileUrl + elev);
    }

    function getElevContent(elevValue) {
        var elevContent = "";
        resultElevation = Math.round(elevValue);
        if (!isElevMap) {
            if (elev > elevValue)
                elevContent = elevContent + "<span style='color:red'><b>Probable Water Level:" + Math.round(elev - elevValue) + " meters.</b></span>";
            else if (elevValue - elev <= 5)
                elevContent = elevContent + "<span style='color:orange'><b>Above Water Level:" + Math.round(elevValue - elev) + " meters.</b></span>";
            else if (elevValue - elev > 5)
                elevContent = elevContent + "<span style='color:green'><b>Above Water Level:" + Math.round(elevValue - elev) + " meters.</b></span>";
            }

            elevContent = elevContent + "<br><b>Elevation: <span style='font-size:1.2em;'><span class='badge' style='background-color:#337ab7;'>" + Math.round(elevValue) + "</span></span> meters</b>";
            if (!isElevMap) {
                //elevContent = elevContent + " + <b><input id='addElev' type='text' value='0' style='width:20px' /></b > <br><input type='button' onclick='$(\"#myModal\").modal()' value='Set Water Level' /><br />";
                elevContent = elevContent + " + <b><input id='addElev' type='text' value='0' style='width:20px' /></b > <br><input type='button' onclick='setElev(" + Math.round(elevValue) + " + parseInt(document.getElementById(\"addElev\").value),true)' value='Set Water Level' /><br />";
            }
            return elevContent;
    }

    function getElevContentOld(elevValue) {
        var elevContent = "";
        resultElevation = Math.round(elevValue);
        if (elev > elevValue)
            elevContent = elevContent + "<span style='color:red'><b>Probable Water Level:" + Math.round(elev - elevValue) + " meters.</b></span>";
        else if (elevValue - elev <= 5)
            elevContent = elevContent + "<span style='color:orange'><b>Above Water Level:" + Math.round(elevValue - elev) + " meters.</b></span>";
        else if (elevValue - elev > 5)
            elevContent = elevContent + "<span style='color:green'><b>Above Water Level:" + Math.round(elevValue - elev) + " meters.</b></span>";

        elevContent = elevContent + "<br><b>Elevation: <span style='font-size:1.2em;'>" + Math.round(elevValue) + "</span> meters + <input id='addElev' type='text' value='0' style='width:20px'/></b><br><input type='button' onclick='$(\"#myModal\").modal()' value='Set Water Level'/><br/>";
        return elevContent;
    }

    function updateLink() {
        center = map.getCenter();
        var lngUrl = "";
        document.getElementById("link").value = "Map center: Latitude:" + Math.round(center.lat * 1000000) / 1000000 + ", Longitude: " + Math.round(center.lng * 1000000) / 1000000 + ", Zoom level: " + map.getZoom() + ", Simulated Sea Level: " + elev;
        
    }

    function updateAMISAFE(){
        center = map.getCenter();
        document.getElementById("amisafeEntry").value =  Math.round(center.lat * 1000000) / 1000000 + ',' + Math.round(center.lng * 1000000) / 1000000;
    }

    
    function setBasemap(basemap) {
        if (basemap === 'Basemap') {
            if (mumbai_popn_density) {
                map.removeLayer(geojson);
                mumbai_popn_density = false;
            }

            if (vulnerability_map) {
                map.removeLayer(vulnerability_map);
            }

            if (crowd_sourced_photos.length > 1) {
                for (var i = 0; i < crowd_sourced_photos.length; i++) {
                    map.removeLayer(crowd_sourced_photos[i]);
                }
                crowd_sourced_photos = [];
            }

            if (!isColorFloodMap)
                floodLayer.bringToFront();
        }

        else if (basemap === 'OpenTopoMap') {
            if (layer) {
                map.removeLayer(layer);
            }
            //'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'
            layer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: ' SRTM | Base Map: Â© <a href="http://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
            }).addTo(map);
            if (!isColorFloodMap)
                floodLayer.bringToFront();
        }

        else if (basemap === 'Population density') {
            // if (mumbai_layer) {
            //     map.removeLayer(mumbai_layer);
            // }
            // if (mumbai_landuse) {
            //     map.removeLayer(svg_landuse);
            //     mumbai_landuse = false;
            // }

            if (vulnerability_map) {
                map.removeLayer(vulnerability_map);
            }
            
            //fetch the geojson and add it to our geojson layer
            getGeoData('https://gist.githubusercontent.com/mickeykedia/9d9144072c5f637c26995569dd347614/raw/b65134846607235adf4ad6498713deed77d3b4b5/Mumbai_Topojson.topojson').then(data => geojson.addData(data));
            
            if (!mumbai_popn_density) {
                geojson.addTo(map);
                mumbai_popn_density = true;
            }
            
            // console.log('geojson bounds:',geojson.getBounds());
            // map.fitBounds(geojson.getBounds());
            map.flyTo([19.102, 72.85], 11);
            if (!isColorFloodMap)
                floodLayer.bringToFront();
        }

        else if (basemap === 'Land use') {
            if (mumbai_popn_density) {
                map.removeLayer(geojson);
                mumbai_popn_density = false;
            }

            if (vulnerability_map) {
                map.removeLayer(vulnerability_map);
            }
            
            var swlat = 18.878474;//18.877702;
            var swlong = 72.674303;//72.671814;
            var nelat = 19.3400180;//19.339653;
            var nelong = 73.045951;//73.048096;
            const latLngBounds = L.latLngBounds([[nelat, nelong], [swlat, swlong]]);
            // var urlbase = 'http://akshaykore.github.io/mumdata/layer/';
            // var imageUrl = urlbase + "all.png";
            var imageUrl = "https://live.staticflickr.com/65535/53033153700_03d4f79dbc_o.png";
            vulnerability_map = L.imageOverlay(imageUrl, latLngBounds).addTo(map);
	        map.flyTo([19.102, 72.85], 11);
            // mumbai_landuse = true;

            if (!isColorFloodMap)
                floodLayer.bringToFront();
        }

        else if (basemap === 'Crowd-Sourced Photos') {
            
            var flooded_results= JSON.parse('{{flooded_results | tojson}}');
            
            console.log('flooded results:', flooded_results);
            
            for (var flood_idx in flooded_results){
                var flood_img = flooded_results[flood_idx]['image']; //icon url
                var flood_exists = flooded_results[flood_idx]['flood'];
                var flood_severity = flooded_results[flood_idx]['flood_severity'];
                var flood_coord = [ flooded_results[flood_idx]['lon'], flooded_results[flood_idx]['lat']];
                console.log(flood_img);
                console.log('flood exist:', flood_exists);
                console.log('flood coord:', flood_coord);
                console.log('flood severity:', flood_severity)
                
                if (flood_severity === 'low') {
                    var icon_url = leaflet_color_icon['yellow'];
                }

                else if (flood_severity === 'medium') {
                    var icon_url = leaflet_color_icon['orange'];
                }

                else {
                    var icon_url = leaflet_color_icon['red'];
                }

                const flood_icon = L.icon({
                    iconUrl: icon_url,
                    iconSize: [25, 41],
                    iconAnchor: [16, 37],
                    popupAnchor: [0, -28]
                });
                
                var geojsonFeature = {
                    "type": "Feature",
                    "properties": {
                        // "name": "Coors Field",
                        // "amenity": "Baseball Stadium",
                        // "popupContent":"<b>Flood:</b> " + flood_exists
                        popupContent: '<img src="{}" height="120px" width="150px"/>'.format(flood_img)
                    },
                    "geometry": {
                        "type": "Point",
                        "coordinates": flood_coord
                    }
                };

                const coorsLayer = L.geoJSON(geojsonFeature, {

                    pointToLayer(feature, latlng) {
                        return L.marker(latlng, {icon: flood_icon});
                    },
                    // onEachFeature
                    onEachFeature(feature, layer) {
                        if (feature.properties && feature.properties.popupContent) {
                            layer.bindPopup(feature.properties.popupContent)
                        }
                    }
                }).addTo(map);

                crowd_sourced_photos.push(coorsLayer);
            }

            if (!isColorFloodMap)
                floodLayer.bringToFront();
        }

        else if (basemap === 'Population Density (2020)') {
            var geoserver = 'https://sedac.ciesin.columbia.edu/geoserver/wms';
            
            if (layer) {
                map.removeLayer(layer);
            }
            layer = L.tileLayer.wms(geoserver, {
                layers: 'gpw-v4:gpw-v4-population-density_2020'+','+'cartographic:00-global-labels',
                format: 'image/png',
                transparent: true
            }).addTo(map);
            map.flyTo([0, 90], 3);

            if (!isColorFloodMap)
                floodLayer.bringToFront();
        }

        else if (basemap === 'Road network map') {
            if (mumbai_popn_density) {
                map.removeLayer(geojson);
                mumbai_popn_density = false;
            }

            // if (mumbai_landuse) {
            //     map.removeLayer(svg_landuse);
            //     mumbai_landuse = false;
            // }

            if (vulnerability_map) {
                map.removeLayer(vulnerability_map);
            }
            
            var swlat = 18.878474;//18.877702;
            var swlong = 72.674303;//72.671814;
            var nelat = 19.3400180;//19.339653;
            var nelong = 73.045951;//73.048096;
            const latLngBounds = L.latLngBounds([[nelat, nelong], [swlat, swlong]]);
            // var urlbase = 'http://akshaykore.github.io/mumdata/layer/';
            // var imageUrl = urlbase + "all.png";
            var imageUrl = "http://akshaykore.github.io/mumdata/layers/26july3.gif";
            vulnerability_map = L.imageOverlay(imageUrl, latLngBounds).addTo(map);
	        map.flyTo([19.102, 72.85], 11);
            // mumbai_landuse = true;

            if (!isColorFloodMap)
                floodLayer.bringToFront();
        }

        else if (basemap === '2005 Mumbai flood') {
            if (mumbai_popn_density) {
                map.removeLayer(geojson);
                mumbai_popn_density = false;
            }

            if (vulnerability_map) {
                map.removeLayer(vulnerability_map);
            }
            
            var swlat = 18.878474;//18.877702;
            var swlong = 72.674303;//72.671814;
            var nelat = 19.3400180;//19.339653;
            var nelong = 73.045951;//73.048096;
            const latLngBounds = L.latLngBounds([[nelat, nelong], [swlat, swlong]]);
            // var urlbase = 'http://akshaykore.github.io/mumdata/layer/';
            // var imageUrl = urlbase + "all.png";
            var imageUrl = "http://akshaykore.github.io/mumdata/layers/26july2.gif";
            vulnerability_map = L.imageOverlay(imageUrl, latLngBounds).addTo(map);
	        map.flyTo([19.102, 72.85], 11);
            // mumbai_landuse = true;

            if (!isColorFloodMap)
                floodLayer.bringToFront();
        }

        else if (basemap === 'Vulnerability index') {
            if (mumbai_popn_density) {
                map.removeLayer(geojson);
                mumbai_popn_density = false;
            }

            // if (mumbai_landuse) {
            //     map.removeLayer(svg_landuse);
            //     mumbai_landuse = false;
            // }

            if (vulnerability_map) {
                map.removeLayer(vulnerability_map);
            }

            var swlat = mumbai_vulnerability_map['vulnerability_index']['LR'][0];
            var swlong = mumbai_vulnerability_map['vulnerability_index']['UL'][1];
            var nelat = mumbai_vulnerability_map['vulnerability_index']['UL'][0];
            var nelong = mumbai_vulnerability_map['vulnerability_index']['LR'][1];
            const latLngBounds = L.latLngBounds([[nelat, nelong], [swlat, swlong]]);
            var imageUrl = "https://live.staticflickr.com/65535/53037585656_aae07f56f1_o.png";
            vulnerability_map = L.imageOverlay(imageUrl, latLngBounds).addTo(map);
            
            map.flyTo([19.102, 72.85], 11);

            if (!isColorFloodMap)
                floodLayer.bringToFront();
        }

        else if (basemap === 'Vulnerability classification') {
            if (mumbai_popn_density) {
                map.removeLayer(geojson);
                mumbai_popn_density = false;
            }

            if (vulnerability_map) {
                map.removeLayer(vulnerability_map);
            }

            var swlat = mumbai_vulnerability_map['vulnerability_index']['LR'][0];
            var swlong = mumbai_vulnerability_map['vulnerability_index']['UL'][1];
            var nelat = mumbai_vulnerability_map['vulnerability_index']['UL'][0];
            var nelong = mumbai_vulnerability_map['vulnerability_index']['LR'][1];
            const latLngBounds = L.latLngBounds([[nelat, nelong], [swlat, swlong]]);
            var imageUrl = "https://live.staticflickr.com/65535/53037033252_7a3f233d46_o.png";
            vulnerability_map = L.imageOverlay(imageUrl, latLngBounds).addTo(map);
            
            map.flyTo([19.102, 72.85], 11);

            if (!isColorFloodMap)
                floodLayer.bringToFront();
        }

        else if (basemap === 'Land subsidence') {
            if (mumbai_popn_density) {
                map.removeLayer(geojson);
                mumbai_popn_density = false;
            }

            if (vulnerability_map) {
                map.removeLayer(vulnerability_map);
            }

            var swlat = mumbai_vulnerability_map['vulnerability_index']['LR'][0];
            var swlong = mumbai_vulnerability_map['vulnerability_index']['UL'][1];
            var nelat = mumbai_vulnerability_map['vulnerability_index']['UL'][0];
            var nelong = mumbai_vulnerability_map['vulnerability_index']['LR'][1];
            const latLngBounds = L.latLngBounds([[nelat, nelong], [swlat, swlong]]);
            var imageUrl = "https://live.staticflickr.com/65535/53033381678_8465947f43_o.png";
            vulnerability_map = L.imageOverlay(imageUrl, latLngBounds).addTo(map);
            
            map.flyTo([19.102, 72.85], 11);

            if (!isColorFloodMap)
                floodLayer.bringToFront();
        }

        else if (basemap === 'Topography') {
            if (mumbai_popn_density) {
                map.removeLayer(geojson);
                mumbai_popn_density = false;
            }

            if (vulnerability_map) {
                map.removeLayer(vulnerability_map);
            }

            var swlat = mumbai_vulnerability_map['vulnerability_index']['LR'][0];
            var swlong = mumbai_vulnerability_map['vulnerability_index']['UL'][1];
            var nelat = mumbai_vulnerability_map['vulnerability_index']['UL'][0];
            var nelong = mumbai_vulnerability_map['vulnerability_index']['LR'][1];
            const latLngBounds = L.latLngBounds([[nelat, nelong], [swlat, swlong]]);
            var imageUrl = "https://live.staticflickr.com/65535/53033381658_152351a299_o.png";
            vulnerability_map = L.imageOverlay(imageUrl, latLngBounds).addTo(map);
            
            map.flyTo([19.102, 72.85], 11);

            if (!isColorFloodMap)
                floodLayer.bringToFront();
        }

        else if (basemap === 'Global vulnerability map') {

            if (!global_vulnerability_map){
                var imageoverlays = {};
                for (var xyz in ssp5_2100_e1) {
                    var swlat = ssp5_2100_e1[xyz]['LR'][0];
                    var swlong = ssp5_2100_e1[xyz]['UL'][1];
                    var nelat = ssp5_2100_e1[xyz]['UL'][0];
                    var nelong = ssp5_2100_e1[xyz]['LR'][1];
                    const latLngBounds = L.latLngBounds([[nelat, nelong], [swlat, swlong]]);
                    var imageUrl = ssp5_2100_e1[xyz]["url"];
                    var overlayer = L.imageOverlay(imageUrl, latLngBounds).addTo(map);
                    imageoverlays[xyz] = overlayer;
                }
                global_vulnerability_map = true;
                map.flyTo([0, 90], 3);
            }
            
            if (layer) {
                map.removeLayer(layer);
            }
            layer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
            
            if (!isColorFloodMap)
                floodLayer.bringToFront();

        }

        else {

            
            var geoserver = 'https://sedac.ciesin.columbia.edu/geoserver/wms';
            var basemap_split = basemap.split("_");
            var ssp_type = basemap_split[0];
            var ssp_year = Number(basemap_split[1]);
            // console.log(ssp_type);
            console.log(ssp_gpp[ssp_type][ssp_year]['name']);
            console.log(ssp_gpp[ssp_type][ssp_year]['uri']);
            if (layer) {
                map.removeLayer(layer);
            }
            layer = L.tileLayer.wms(geoserver, {
                layers: ssp_gpp[ssp_type][ssp_year]['name']+','+'cartographic:00-global-labels',
                format: 'image/png',
                transparent: true
            }).addTo(map);
            map.flyTo([0, 90], 3);

            // add legend
            var uri = ssp_gpp[ssp_type][ssp_year]['uri'];
            // L.wmsLegend(uri,map);
            // legend.addTo(map,[ssp_gpp[ssp_type][ssp_year]['uri']]);
            if (global_vulnerability_map) {
                for (var xyz in ssp5_2100_e1) {
                    map.removeLayer(imageoverlays[xyz]);
                }
            }

            if (!isColorFloodMap)
                floodLayer.bringToFront();
        }
        
    }

    function sspDescription(ssp_type, ssp_year) {
        var gpp = 'Global Population Prediction';

        if (ssp_type === 'ssp1') {
            var legend_desc = '{} for {} (year {}): Sustainability (Taking the Green Road)'.format(ssp_type.toUpperCase(), gpp, ssp_year);
        }

        else if (ssp_type === 'ssp2') {
            var legend_desc = '{} for {} (year {}): Middle of the Road'.format(ssp_type.toUpperCase(), gpp, ssp_year);
        }

        else if (ssp_type === 'ssp3') {
            var legend_desc = '{} for {} (year {}): Regional Rivalry (A Rocky Road)'.format(ssp_type.toUpperCase(), gpp, ssp_year);
        }

        else if (ssp_type === 'ssp4') {
            var legend_desc = '{} for {} (year {}): Inequality (A Road divided)'.format(ssp_type.toUpperCase(), gpp, ssp_year);
        }

        else {
            var legend_desc = '{} for {} (year {}): Fossil-fueled Development (Taking the Highway)'.format(ssp_type.toUpperCase(), gpp, ssp_year);
        }

        return legend_desc;
    }

    legend_imgs = {
        'Basemap': 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
        'Population density': "https://live.staticflickr.com/65535/53037896916_d0535749df_o.png",
        'Land use': "https://live.staticflickr.com/65535/53037319537_59106904dd_o.png",
        'Land subsidence': "https://live.staticflickr.com/65535/53038383823_0580c886ba_o.png",
        'Topography': "https://live.staticflickr.com/65535/53037896931_77802e80a5_o.png",
        '2005 Mumbai flood': 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
        "Crowd-Sourced Photos": 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
        'Vulnerability index': "https://live.staticflickr.com/65535/53037319522_c2a141c886_o.png",
        'Vulnerability classification':"https://live.staticflickr.com/65535/53037175697_8545f2a21a_o.png"
    }
    function updateLegend(basemap) {
        var legend_img = document.getElementById('legend');
        legend_img.src = legend_imgs[basemap];
    };
        // var legend_desc = document.getElementById('legend_desc');

        // if (basemap === 'OpenStreetMap') {
        //     legend_img.src = null;
        // }

        // else if (basemap === 'OpenTopoMap') {
        //     legend_img.src = null;
        //     legend_desc.textContent = '{} is a free topographic map generated from OpenStreetMap data and SRTM elevation data. The map style is based on the official maps and focuses on good readability through high contrast and balanced signatures.'.format(basemap);
        // }

        // else if (basemap === 'Land use') {
        //     legend_img.src = "https://live.staticflickr.com/65535/53037319537_01beda9b69_o.png";
        //     // legend_desc.textContent = null;

        //     // var miniClass = document.querySelector('.landuselegend');
        //     // miniClass.innerHTML = ``;
        //     // function showLegend() {
        //     //     for (let i = 0; i < legenddata.length; i++){
        //     //         if (legenddata[i]['type'] === "static"){
        //     //             var legend_uri = legenddata[i]['legend'];
        //     //             var legend_description = legenddata[i]['name'];
        //     //             miniClass.innerHTML +=  ` <img src="${legend_uri}"> ${legend_description} <br>`;
        //     //         }
        //     //     }
        //     // }

        //     // showLegend();

        // }


        // else if (basemap === 'Mumbai Population Density') {
        //     legend_img.src = null;
        //     legend_desc.textContent = null;

        //     var miniClass = document.querySelector('.landuselegend');
        //     miniClass.innerHTML = ``;
        //     miniClass.innerHTML = `<div class='my-legend'>
        //     <div class='legend-title'>Mumbai Population Density (people / km<sup>2</sup> (2011))</div>
        //     <div class='legend-scale'>
        //     <ul class='legend-labels'>
        //         <li><span style='background:#FFEDA0;'></span>0 &ndash;5000</li>
        //         <li><span style='background:#FED976;'></span>5000 &ndash;10000</li>
        //         <li><span style='background:#FEB24C;'></span>10000 &ndash;20000</li>
        //         <li><span style='background:#FD8D3C;'></span>20000 &ndash;30000</li>
        //         <li><span style='background:#FC4E2A;'></span>30000 &ndash;40000</li>
        //         <li><span style='background:#E31A1C;'></span>40000 &ndash;50000</li>
        //         <li><span style='background:#BD0026;'></span>50000 &ndash;90000</li>
        //         <li><span style='background:#800026;'></span>90000 +</li>
        //     </ul>
        //     </div>
        //     <div class='legend-source'>Source: <a href="https://github.com/mickeykedia/Mumbai-Population-Map">Mumbai Population Data Map</a></div>
        //     </div>`;
        // }

        // else if (basemap === 'Population density') {
        //     // legend_img.src = 'https://sedac.ciesin.columbia.edu/geoserver/ows?service=WMS&request=GetLegendGraphic&format=image/png&width=15&height=15&layer=gpw-v4:gpw-v4-population-density-adjusted-to-2015-unwpp-country-totals_2020&style=gpw-v4-population-density-adjusted-to-2015-unwpp-country-totals_2020:default&';
        //     legend_img.src = "https://live.staticflickr.com/65535/53037896916_d0535749df_o.png";
        //     // legend_desc.textContent = '{} consists of estimates of human population density based on counts consistent with national census and population registers for the year 2020.'.format(basemap);
        // }

        // else if (basemap === 'Vulnerability classification') {
        //     legend_img.src = "https://live.staticflickr.com/65535/53037175697_8545f2a21a_o.png";
        //     // legend_desc.textContent = 'High risk areas accounts for aras that are subsiding, high population density and low lying areas that are below mean sea level';
        // }



        // else {
        //     var basemap_split = basemap.split("_");
        //     var ssp_type = basemap_split[0];
        //     var ssp_year = Number(basemap_split[1]);
        //     legend_img.src = ssp_gpp[ssp_type][ssp_year]['uri'];
        //     legend_desc.textContent = sspDescription(ssp_type, ssp_year);
        // }

    

    //Color FloodMap

    var colFloodMap;
    var isElevMap;
    var isSea = "false";
    var oldColMapLayers = new Array();
    var isShowMap = true;
    var colorMapTimeout;
    var colorpal = "blue";

    
    switchToFloodMap();
    
    $('input[type=radio][name=floodmap]').change(function () {
        if (this.value == 'floodmap') {
            $('#previewbox').hide();
            $('#setElev').show();
            $('#clickOnLabel').html('<b><span style="color: orange; ">Click on the Map</span> to get/set the flood water level at the location.</b>');
            isElevMap = false
            switchToFloodMap();
        }
       
    });

    function switchToFloodMap() {
        $('#colOpt').hide();
        isColorFloodMap = false;
        map.options.maxZoom = 22;
        colorpal = "blue";
        //$('#mapPanel').removeClass("col-md-9").addClass("col-md-12");
        //$('#colPanel').hide();
        //map.invalidateSize();
        if (map.hasLayer(colorWait)) {
            map.removeLayer(colorWait);
        }
        floodLayer.setUrl(fmTileUrl + elev);
        map.addLayer(floodLayer);
        try {
            var arrayLength = oldColMapLayers.length;

            for (var i = 0; i < arrayLength; i++) {
                if (map.hasLayer(oldColMapLayers[i])) {
                    map.removeLayer(oldColMapLayers[i]);
                }
                oldColMapLayers = [];
            }
        } catch (e) { }
    }

    var waitIcon = L.icon({
        iconUrl: '/img/colorwait.gif',
        iconSize: [40, 40], // size of the icon
        iconAnchor: [20, 20], // point of the icon which will correspond to marker's location
    });
    var colorWait = new L.marker(map.getCenter(), { icon: waitIcon, clickable: false });
    map.on('move', function (e) {
        colorWait.setLatLng(map.getCenter());
    });
    var colorwaitTimeout, retryTimeout;
    var showImage = true;
    var zoomstart = false;
    </script>
    
    <script type="application/javascript" src="https://sdki.truepush.com/sdk/v2.0.2/app.js" async></script>
    <script>
        var truepush = window.truepush || [];
        truepush.push(function () {
            truepush.Init({
                id: "5f1a712a8cf1e2671f4d75f7"
            }, function (error) {
                if (error) console.error(error);
            })
        })
    </script>

{% endblock %}